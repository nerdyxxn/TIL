# 프론트엔드 기술 면접 준비 - Javscript

<br>

## 💡 브라우저의 렌더링 과정에 대해 설명해주세요.

> 1. 사용자가 특정 페이지에 접속하여 HTML을 서버로부터 내려받으면, 브라우저의 렌더링 엔진에서는 이를 파싱한다.
> 2. HTML 파싱을 진행하면서, DOM 트리를 만들게 되는데, 이 때 Link 태그를 만나 StyleSheet를 내려받게 될 경우 CSS 파싱을 통해 CSSOM 트리를 만들게 된다.
> 3. 이 일련된 과정을 통해 둘을 결합하여 렌더 트리를 만들고, 레이아웃 작업을 통해 사용자에게 그려줄 영역을 계산한 뒤, 화면에 뿌려주게된다.
> 4. 위 과정을 진행하면서 자바스크립트를 만나면, 자바스크립트 런타임 환경에 컨트롤(수행권한)을 넘겨 결과 값을 받는다. 이 과정 중, DOM파싱은 중단된다.
> 5. 생성된 DOM 노드의 레이아웃 수치(너비, 높이, 위치 등) 변경 시 영향 받은 모든 노드의 수치를 재계산하여, 렌더 트리를 재생성하는 과정을 Reflow 과정이라고 하며, 이 과정이 끝난 후 재생성된 렌더 트리를 다시 그리게 되는데 이 과정을 Repaint라고 한다.
>
> - reflow가 이루어졌다고 항상 repaint가 되는 것은 아니며, background-color, visibillty, outline 등 레이아웃 수치에 영향을 끼치지 않는 것은 repaint 과정만 진행된다.

<br>
<br>

## 💡 호이스팅에 대해 설명해주세요.

> 1. 함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것을 말한다.
> 2. 호이스팅에는 함수 호이스팅과 변수 호이스팅이 있는데, 변수 호이스팅의 경우 각 변수 선언 키워드 마다 차이가 있다.
> 3. 함수 호이스팅의 경우에는 함수 선언식을 통해 작성한 함수는 해당 함수의 내부 블럭까지 호이스팅되기 때문에 어디서든지 사용할 수 있으나, 함수 표현식의 경우에는 변수 호이스팅과 동일하게 동작하기 때문에 이 점을 유의하여 코드를 작성해야 한다.

<br>
<br>

## 💡 클로저는 무엇인가요? 원리와 사용하는 이유를 설명해주세요.

> 1. 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(스코프)을 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수이다.
> 2. 즉, 자신을 감싸고 있는 바깥 함수의 변수에 접근할 수 있는 내부의 함수를 모두 클로저라 부른다. 이러한 클로저의 사용을 통해 전역 변수의 사용을 억제할 수 있고, OOP의 장점 중 하나인 캡슐화를 통해 데이터의 은닉화가 가능해진다.
> 3. 모든 함수는 각자의 실행 컨텍스트에 스코프 체인을 가지고 있는데, 외부 함수에 대한 실행이 종료되어도 스코프 체인은 유지된다는 원리를 통해 클로저의 구현이 가능해진다. (스코프 체인을 통한 외부 함수의 실행 컨텍스트에 대한 객체 변수에 접근이 가능해짐)

<br>
<br>

## 💡 this 용법을 아는대로 설명해주세요.

> this는 '자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수'이다. this는 함수의 호출 방식에 따라 특정 객체를 바인딩하게 된다.

- 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스와 바인딩된다.
- Call, Apply, Bind 메소드 사용 시, 함수의 첫 번째 인수로 전달하는 객체에 바인딩된다.
- Object.method 형태와 같이 객체 내에서 호출할 경우, this는 해당 객체와 바인딩된다.
- 위 세 가지를 제외한 일반적인 함수 호출의 경우, this는 전역 객체와 바인딩된다.
- 마지막으로 ES6의 화살표 함수 내에서 this가 사용될 경우, this는 상위 스코프의 this와 바인딩된다.

<br>
<br>

## 💡 브라우저 저장소에 대해 설명해주세요.

> 브라우저 저장소로는 쿠키와 HTML5를 통해 추가된 LocalStorage, SessionStorage가 있다.
> HTML5를 통해 새롭게 추가되었다 하더라도 기존의 쿠키가 쓰이지 않는 것은 아니며, 각 활용 특성에 따라 적절히 사용하는 것이 좋다.
>
> 웹 애플리케이션에서 쿠키를 설정하면 이후 모든 웹 요청은 쿠키정보를 포함하여 서버로 전송하게 되며, 새로이 추가된 WebStorage의 경우에는 클라이언트에만 존재할 뿐 서버로 전송되지 않는다.
> 이는 네트워크 트래픽 비용을 줄여준다는 장점이 있다.
>
> 쿠키는 WebStorage와 다르게 단순 문자열만 저장할 수 있으며 용량에 제한이 있고, 저장된 데이터는 영구적이지 않다.
> LocalStorage는 데이터를 영구적으로 저장할 수 있으나, SessionStorage는 이름에서 알 수 있듯이 브라우저가 종료되면 데이터도 같이 지워지는 특성이 있다.

<br>
<br>

## 💡 Restful API에 대해서 아는대로 설명해주세요.

> **REST**란 HTTP URI를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.
> **API**란 데이터와 기능의 집합을 제공함으로써 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환 가능하도록 하는 것이다.
> **RESTAPI**는 **REST**를 기반으로 **서비스 API**를 구현한 것으로 설명할 수 있다.

<br>

- CRUD Operation
  - Create: 생성(POST)
  - Read: 조회(GET)
  - Update: 수정(PUT)
  - DELETE: 삭제(DELETE)
  - HEAD: header 정보 조회(HEAD)

<br>

#### 1. REST가 필요한 이유

> 기술의 발전으로 다양한 클라이언트가 등장하면서 자연스레 멀티 플렛폼의 지원을 위한 아키텍처가 필요해짐

<br>

#### 2. REST의 장점

> HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구축할 필요가 없으며, HTTP 표준 프로토콜을 따르는 모든 플랫폼에서 사용이 가능하다.
> 서버와 클라이언트의 역할을 명확하게 분리할 수 있다.

<br>

#### 3. REST의 단점

> 구형 브라우저의 경우 PUT, DELETE 메소드를 지원하지 않으며, 사용할 수 있는 HTTP Method의 형태가 제한적이다.

<br>
<br>

## 💡 Javascript는 어떤 언어인가요?

> Javascript는 싱글 스레드 언어이므로, 단일 호출 스택이 있다. 단일 호출 스택이 있다는 것은 한 번에 하나의 일만 처리할 수 있다는 뜻이다. 만일 브라우저에서 무거운 처리를 진행하려고 하면 단일 스레드로 인해 작업에 블로킹이 발생할 수 있다.
> 브라우저에서의 블로킹은 웹에 대한 기능 혹은 UI가 멈추는 것을 의미한다.
>
> 이러한 단점을 극복하기 위한 해결 방안이 바로 비동기 콜백이다.
> 싱글 스레드 언어임에도 불구하고 웹사이트에서 여러 작업을 동시에 할 수 있는 것은 브라우저가 Web APIs(Application Programming Interfaces)를 제공하여 비동기 작업을 가능하게 해주기 때문이다.
>
> 만일 함수를 동기 호출하게 되면 호출 스택에 차곡차곡 쌓여 순차적으로 실행되게 된다.
> 이 때, AJAX나 setTimeout 혹은 DOM event 함수를 실행하면, Javascript 엔진은 호출 스택에서 Web APIs로 보내고 정해진 시간 혹은 이벤트가 발생한 순간에 순차적으로 Callback queue(Task Queue)에 적재한다.
> Callback queue에 적재된 함수들은 호출 스택에 쌓여있던 태스크들이 모두 처리될 경우, 차례대로 스택에 쌓여서 실행되게 된다.

<br>
<br>

## 💡 이벤트 버블링에 대해서 말씀해주세요.

> 이벤트 버블링은 특정 화면 요소에서 이벤트가 발생했을 때, 해당 이벤트가 더 상위의 화면 요소들로 전달되는 특성을 의미한다. 이벤트 버블링은 이벤트 위임의 동작 메커니즘이라고 볼 수 있다.

<br>

> **Q: 이벤트 버블링은 기본적으로 child -> parent 인데 반대로 구현하는 방법은 무엇일까요?**
>
> - 반대로 구현하는 것을 보통 이벤트 캡쳐라고 한다.
>   addEventListener의 옵션 객체에 capture: true 를 설정해주면 된다.

> **Q: 이벤트 버블링을 막기 위한 방법은 무엇일까요?**
>
> - stopPropagation();를 사용하여 이벤트의 전파를 막을 수 있다.

<br>
<br>

## 💡 Promise와 Callback의 차이점은 무엇이며 각각의 장단점에 대해서 설명해주세요.

> 둘 다 자바스크립트에서 비동기처리를 위해 사용되는 패턴이다.
> Callback은 함수의 처리 순서를 보장하기 위해서 함수를 중첩되게 사용하는 경우가 발생해 콜백지옥이 발생한다는 것과 에러 처리가 힘들다는 단점이 있다.
> 이러한 단점을 해결하기 위해 ES6에서부터 Promise를 정식 채택하여 사용하고 있다.

<br>
<br>

## 💡 Async, Await가 무엇인가요? Promise와의 차이점을 설명해주세요.

> Promise를 더욱 쉽게 사용할 수 있도록 하는 ES8 문법이다.
> 함수의 앞부분에 async 키워드를 추가하고 함수 내부에서 Promise의 앞부분에 await 키워드를 사용하면 된다.
> async, await을 사용할 경우 **Promsise ... then**보다 코드가 간결해지며 에러 핸들링의 경우에는 **try...catch**를 사용해야 한다.
> async가 사용된 함수는 promise를 반환하기 때문에 사용 시 유의해야 한다.

<br>
<br>

## 💡 프로토타입이 무엇인지 설명해주세요.

> 자바스크립트는 기존의 객체를 복사하여 새로운 객체를 생성하는 프로토타입 기반의 언어로, 클래스의 개념이 존재하지 않는다.
>
> 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 이는 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다.
> 이러한 부모 객체를 프로토타입 객체 또는 줄여서 프로토타입(Prototype)이라 한다.
>
> 프로토타입 객체는 생성자 함수에 의해 생성된 각각의 객체에 공유 프로퍼티를 제공하기 위해 사용한다.

<br>
<br>

## 💡 HTML Body 최하단에 Script 태그를 작성해야 하는 이유가 있을까요?

> Script 태그를 처리할 때에는 DOM 파싱이 중단됨으로 사용자에게 화면이 늦게 그려질 수 있다. 모든 DOM 노드가 그려진 뒤 Javascript를 수행될 수 있도록 최하단에 작성하는 것이 좋다.

<br>
<br>

## 💡 Mutable과 Immutable을 설명하세요.

> Mutable은 바뀔 수 있는 변수 타입을 말하며, Immutable은 이와 반대되는 개념이다.
> Javascript에서는 Object와 Array만 Mutable한 타입이고, 다른 원시 타입의 경우 Immutable하다고 볼 수 있다.

<br>
<br>

## 💡 Throttle과 Debounce의 차이를 설명하세요.

> 두 가지는 DOM 이벤트를 기반으로 실행하는 자바스크립트를 성능상의 이유로 JS의 양적인 측면, 즉 이벤트를 제한하는 방법이다.
> 스크롤 이벤트와 같이, 이벤트가 많이 발생하는 경우에 대해 적용시켜 사용하는 것이 보편적이다.
>
> 1. Throttle은 이벤트를 일정한 주기마다 발생하도록 하는 기술
> 2. Debounce는 이벤트를 그룹화하여, 특정시간이 지난 후 하나의 이벤트만 발생하도록 하는 기술

<br>
<br>

## 💡 requestAnimationFrame이 무엇인가요?

> window.requestAnimationFrame()은 브라우저에게 수행하기를 원하는 애니메이션을 알리고 다음 리페인트가 진행되기 전에 해당 애니메이션을 업데이트하는 함수를 호출하게 한다. 이 메소드는 리페인트 이전에 실행할 콜백을 인자로 받는다.
>
> 반복시킬 함수 안에서 requestAnimationFrame() 메소드를 사용하는데, 이 때 인자로 반복시킬 함수를 넣어준다.

<br>
<br>

## 💡 OOP을 설명해주세요.

> OOP란 Object Oriented Programming, 즉 객체지향 프로그래밍을 말한다.
> 객체지향 프로그래밍이란 객체들이 유기적으로 동작하는 프로그래밍 이론을 뜻하며, 객체지향 프로그래밍을 하는 주요 이유으로는 코드 재사용 및 중복 제거 등이 있다.

- **OOP(Object Oriented Programming)의 4가지 특성**
  - 다형성 - 선언되어있는 하나의 메소드를 오버라이딩하여 여러가지의 기능으로 동작시킬 수 있는 것
  - 캡슐화 - 데이터와 데이터 구조를 묶음으로써 외부에 데이터를 노출시키지 않는 데이터 은닉화가 가능한 것
  - 상속 - 상속관계에 있는 두 클래스에서 자식 클래스가 부모 클래스의 메소드를 상속받아 사용함으로써 코드의 재사용이 가능한 것
  - 추상화 - 클래스에 대해 공통 속성이나 기능을 묶어 이름을 붙여서 객체지향 관점으로 봤을 때 추상화가 가능하다는 것

<br>
<br>

## 💡 FP를 설명해주세요.

> FP란 Functional Programming, 즉 함수 프로그래밍을 말한다.
>
> FP는 순수함수로 이루어져있는 프로그래밍 방식을 말하며 순수함수란 사이드이펙트가 없는 것, 즉 항상 동일한 인풋에 동일한 아웃풋이 나오는 함수를 말한다.
>
> 이러한 함수의 조합과같은 합성함수나, Point-free, 재귀함수의 사용 등 함수형 프로그래밍 방식을 사용해 코드를 구성하는 것을 말한다.

<br>
<br>
