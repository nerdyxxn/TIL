# 연산자

> **연산자[용어]** 는 **하나 이상**의 표현식을 대상으로 연산을 수행해 하나의 값을 만든다. 이때 **연산 대상**을 **피연산자** 라고 한다. **꼭!** **피연산자는 값**이여야 한다.

<br>

## 1. 산술 연산자

<br>

피연산자를 대상으로 **수학적 계산**을 수행해 **새로운 숫자값**을 만든다.

→ **부수 효과(side effect)[용어]** 가 없다. 언제나 **새로운 값** 을 만든다.

<br>

**What 부수 효과?**

**피연산자의 값이 변경되면** 부수 효과가 일어났다고 한다.

<br>

**But!산술 연산이 불가능**하면 `NaN` 을 반환한다.

<br>

**피연산자**의 **개수**에 따라

1. **이항 산술 연산자[용어]**
2. **단항 산술 연산자[용어]**

로 구분한다.

<br>

### 1-1 이항 산술 연산자

말 그대로 **2개**의 **피연산자**를 산술 **연산**한다.

<br>

피연산자의 **값을 변경**하면 발생하는 **부수효과(side effect)[용어]** 가 없다.

→ 언제나 새로운 값을 만들지 **피연산자**의 **값은 변하지 않는다**.

<br>

**What? 이항 산술 연산자는 무엇이 있을까?**

+, -, \*, /, %

<br>

흔히 아는 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 값.

<br>

### 1-2 단항 산술 연산자

<br>

**1개**의 피연산자만 **연산**해서 숫자값을 만든다.

<br>

++ → 증가

-- → 감소

<br>

**++와 - - 연산자**는 피연산자의 **값**을 변경하는 **암묵적**으로 할당하는 **부수효과가** **있다**.

<br>

**중요** **주의!**

**증가(++)** **감소(- -)** 연산자의 **위치**에 의미가 있다.

<br>

1 . 피연산자 **앞**에 위치 → **먼저 피연산자의 값을 증가/감소**시킨 후, 다른 연산을 수행한다.

ex) 할당 연산자 다음에 위치하면 연산자 우선순위로 **먼저 값을 증가/감소 시킨후** **할당**함.

<br>

```jsx
var x = 5,
  result;

// 선증가 후할당(prefix increment operator)
result = ++x;
console.log(result, x); // 6 6
// -> 1. x 의 값이 5에서 6으로 증가부터 먼저함.
// -> 2. 그이후 다른 연산을 수행함
// -> 3. 다른 연산으로는 할당 연산자(=) 가 있으므로 result에 숫자 값 6 할당.

result = --x;
console.log(result, x); // 5 5
// -> 1. x 의 값이 6에서 5으로 감소부터 먼저함.
// -> 2. 그이후 다른 연산을 수행함
// -> 3. 다른 연산으로는 할당 연산자(=) 가 있으므로 result에 숫자 값 5 할당.
```

<br>

2 . 피연산자 **뒤**에 위치 → **먼저 다른 연산을 수행한 후**, 피연산자의 값을 증가/감소시킨다.

ex) 할당 연산자 다음에 위치하면 변수에 값을 **할당**한뒤 피연산자의 **값**을 **증가/감소**시킨다.

```jsx
var x = 5,
  result;

// 선할당 후증가(postfix increment operator)
result = x++;
console.log(result, x); // 5 6
// -> 1. 먼저 다른 연산을 수행
// -> 2. 다른연산으로는 할당 연산자(=) 가 있으므로 result에 숫자값 5 할당
// -> 3. 그이후 x의 값이 5에서 6으로 증가

// 선할당 후감소(postfix decrement operator)
result = x--;
console.log(result, x); // 6 5
// -> 1. 먼저 다른 연산을 수행
// -> 2. 다른연산으로는 할당 연산자(=) 가 있으므로 result에 숫자값 6 할당
// -> 3. 그이후 x의 값이 6에서 5으로 감소
```

<br>

플러스(+) → 아무효과가 없다. 하지만 **숫자타입**으로 **강제 변환**시킨다.

```jsx
var x = '1';

// 문자열을 숫자로 타입 변환한다.
console.log(+x); // 1
// 부수 효과는 없다.
console.log(x); // "1"

// 불리언 값을 숫자로 타입 변환한다.
x = true;
console.log(+x); // 1
// 부수 효과는 없다.
console.log(x); // true

// 불리언 값을 숫자로 타입 변환한다.
x = false;
console.log(+x); // 0
// 부수 효과는 없다.
console.log(x); // false

// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
x = 'Hello';
console.log(+x); // NaN -> 숫자가 아니므로!
// 부수 효과는 없다.
console.log(x); // "Hello"
```

마이너스( - ) → 양수를 음수

음수를 양수로 **반전** 하여 **반환** 한다.

<br>

**즉!**

마이너스( - ) 단항 연산자는 숫자 타입으로 **강제 변환** 시킨다. 또한 **부호도 반전**시킨다.

```jsx
// 부호를 반전한다.
-(-10); // -> 10

// 문자열을 숫자로 타입 변환한다.
-'10'; // -> -10

// 불리언 값을 숫자로 타입 변환한다.
-true; // -> -1

// 문자열은 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
-'Hello'; // -> NaN
```

<br>

### 1-3 문자열 연결 연산자

<br>

플러스(+) 연산자는 **피연산자 중** 하나 이상이 **문자열**인 경우 **문자열** **연결 연산자[용어]로 동작**한다.

<br>

```jsx
// 문자열 연결 연산자
'1' + 2; // -> '12'
1 + '2'; // -> '12'

// 산술 연산자
1 + 2; // -> 3

// true는 1로 타입 변환된다.
1 + true; // -> 2

// false는 0으로 타입 변환된다.
1 + false; // -> 1

// null은 0으로 타입 변환된다.
1 + null; // -> 1

// undefined는 숫자로 타입 변환되지 않는다.
+undefined; // -> NaN
1 + undefined; // -> NaN
```

<br>

JS 엔진은 **암묵적**으로 타입이 **자동 변환**한다.

`1 + true; // -> 2` 를 연산하면 JS엔진은 `true` 를 숫자타입 `1` 로 **강제 변환 한후** 연산을 수행한다.

<br>

**What 그럼 이러한 변환을 뭐라고 부를까?**

1. **암묵적 타입 변환(implicit coercion)[용어]**
2. **타입 강제 변환(type coercion)[용어]**

두가지로 부른다.

<br>

## 2. 할당 연산자

<br>

**할당 연산자[용어] 우항**에 있는 피연산자의 **평가 결과**를 **좌항**변수에 **할당**한다.

→ 좌항의 피연산자가 변하는 **부수효과** 가 있다.

<br>

**What 할당 연산자에는 무엇이 있을까?**

[할당 연산자](https://www.notion.so/2f96c657ff2146ac95d8b9d4815a6ebc)

```jsx
var x;

x = 10;
console.log(x); // 10

x += 5; // x = x + 5;
console.log(x); // 15

x -= 5; // x = x - 5;
console.log(x); // 10

x *= 5; // x = x * 5;
console.log(x); // 50

x /= 5; // x = x / 5;
console.log(x); // 10

x %= 5; // x = x % 5;
console.log(x); // 0

var str = 'My name is ';

// 문자열 연결 연산자
str += 'Lee'; // str = str + 'Lee';
console.log(str); // 'My name is Lee'
```

<br>

할당문은 값으로 평가되는 **표현식 문**으로 **할당된 값**으로 평가된다.

<br>

**할당문 = 값**

<br>

**즉!** **할당문**을 **값**처럼 사용할 수 있다.

Ex)

```jsx
var x;

// 할당문은 표현식인 문이다.
console.log((x = 10)); // 10

var a, b, c;

// 연쇄 할당. 오른쪽에서 왼쪽으로 진행.
// ① c = 0 : 0으로 평가된다
// ② b = 0 : 0으로 평가된다
// ③ a = 0 : 0으로 평가된다
a = b = c = 0;

console.log(a, b, c); // 0 0 0
```

<br>

## 3. 비교 연산자

<br>

**비교 연산자[용어]** 는 **좌항**과 **우항**의 피연산자를 **비교**한 다음 그결과를 **불리언 값**으로 **반환** 시킨다.

→ If, for 문 같은 **제어문 조건식**에 사용

<br>

### 3-1 동등 비교 연산자 / 일치 비교 연산자

<br>

**동등 / 일치 비교 연산자[용어]** 는 좌항과 우항을 비교해서 평가해 불리언으로 반환하는 것은 같다.

<br>

**But!**

**동등 비교 연산자[용어]** 는 **값** 만을 **비교**하고

**일치 비교 연산자[용어]** 는 **값과 타입**까지 **비교**한다.

<br>

### 3-1-1 동등 비교 연산자.

<br>

```jsx
// 동등 비교
5 == 5; // -> true

// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.
5 == '5'; // -> true
```

<br>

**How 그렇다면 어떻게 동등비교 연산자는 타입이 아닌 값만 비교 할까?**

동등 비교 연산자는 타입이 아닌 값만을 비교 하기위해

**암묵적으로 타입**을 **변환**시켜 **일치**시킨후 **비교**한다.

<br>

**그렇기 때문에**

동등 비교 연산자는 예측하기 **어려운 결과**를 만든다.

→ 타입이 같지 않더라도 true를 리턴한다.

<br>

```jsx
// 동등 비교. 결과를 예측하기 어렵다.
'0' == ''; // -> false
0 == ''; // -> true
0 == '0'; // -> true
false == 'false'; // -> false
false == '0'; // -> true
false == null; // -> false
false == undefined; // -> false
```

<br>

**따라서!** **동등 비교 연산자**는 **권장하지 않는다**.

<br>

### 3-1-2 일치 비교 연산자

<br>

**일치 비교 연산자[용어](===)** 는 **타입과 값**이 **일치**해야 true를 변환시킨다.

→ 동등 비교 연산자랑 다르게 **암묵적 타입 변환이 없다**!

<br>

```jsx
// 일치 비교
5 === 5; // -> true

// 암묵적 타입 변환을 하지 않고 값을 비교한다.
// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.
5 === '5'; // -> false
```

<br>

**주의사항 1!**

```jsx
// NaN은 자신과 일치하지 않는 유일한 값이다.
NaN === NaN; // -> false
```

→ 데이터 타입때 공부한 isNaN 메소드를 사용하면된다.

```jsx
// isNaN 함수는 지정한 값이 NaN인지 확인하고 그 결과를 불리언 값으로 반환한다.
isNaN(NaN); // -> true
isNaN(10); // -> false
isNaN(1 + undefined); // -> true
```

<br>

**주의사항 2!**

양의 숫자 0 과

음의 숫자 0도 비교시 true를 반환한다.

```jsx
// 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 결과는 true이다.
0 === -0; // -> true
0 == -0; // -> true
```

<br>

**How? 그렇다면 음의 0과 양의 0을 어떻게 비교할까?**

<br>

### 3-2 Object.is

<br>

**Object.is** 메서드를 사용하면된다.

→ 앞에 **동등 비교 연산자(==)** / **일치 비교 연산자(===)** 는 **양의 0**과 **음의 0** 을 **동일** 하다고 보고

**NaN** 을 비교하땐 **서로 다르다** 고 했다.

<br>

**ES6**에서 새롭게 추가된 **Object.is** 를 사용하면 **정확** 하게 반환된다.

<br>

```jsx
-0 === +0; // -> true
Object.is(-0, +0); // -> false

NaN === NaN; // -> false
Object.is(NaN, NaN); // -> true
```

<br>

### 3-3 부동등 비교 연산자(!=) / 불일치 비교 연산자(!==)

<br>

**부동등 비교 연산자[용어]** 와 **불일치 비교 연산자[용어]** 는

동등 / 일치 비교 연산자의 **반대**이다.

<br>

```jsx
// 부동등 비교
5 != 8; // -> true
5 != 5; // -> false
5 != '5'; // -> false

// 불일치 비교
5 !== 8; // -> true
5 !== 5; // -> false
5 !== '5'; // -> true
```

<br>

### 3-4 대소관계 비교 연산자

<br>

피연산자의 **크기**를 비교하여 **불리언**으로 **반환**한다.

<br>

[대소관계 비교 연산자](https://www.notion.so/1ae5bdd496364ec79252ed950bab7f84)

```jsx
// 대소 관계 비교
5 > 0; // -> true
5 > 5; // -> false
5 >= 5; // -> true
5 <= 5; // -> true
```

<br>

=는 항상 우측.

<br>

## 4. 삼함 조건 연산자

<br>

**삼항 조건 연산자[용어]** 는 **조건식의 평가 결과**에 따라 **반환**하는 값을 결정한다.

<br>

**조건식? 조건식이 true : 조건식이 false**

<br>

**물음표(?)** **앞**의 **첫번째** 피연산자는 **'조건식'** 이다.

→ **불리언 타입의 값**으로 반환 평가한다.

<br>

콜론( : )의 **앞이 true** 일때

콜론( : )의 **뒤가 false** 일때

값이 반환된다.

<br>

```jsx
var x = 2;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
var result = x % 2 ? '홀수' : '짝수';

console.log(result); // 짝수
```

<br>

**주의!**

삼함 조건 연산자의 **첫번째 피연산자**는

조건식이므로 **표현식은 조건문**이다.

**if else 문**과도 비슷하게 사용된다.

<br>

```jsx
var x = 2,
  result;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
if (x % 2) result = '홀수';
else result = '짝수';

console.log(result); // 짝수
```

<br>

**하지만!**

**삼항 조건 연산자**는 **값**으로 사용이 가능한 표현식 문이고.

**if else**는 표현식이 아닌문이여서 **값으로 사용할수 없다**.

<br>

**즉!**

**삼항 조건 연산자 = 값**

**if else ≠ 값**

```jsx
var x = 10;

// if...else 문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다.
var result = if (x % 2) { result = '홀수'; } else { result = '짝수'; };
// SyntaxError: Unexpected token if
```

```jsx
var x = 10;

// 삼항 조건 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.
var result = x % 2 ? '홀수' : '짝수';
console.log(result); // 짝수
```

<br>

**따라서!**

**어떤 값을 결정**해야 한다면 **삼항 조건 연산자** 표현식이 유리하다.

<br>

수행해야할 **문**이 하나가 아니라

**여러개면** **if else** 문이 **가독성이 훨씬 좋다**.

<br>

## 5. 논리 연산자

<br>

**논리 연산자[용어]** 는 **우항**과 **좌황**의 피연산자를 **논리 연산**한다.

<br>

[논리 연산자](https://www.notion.so/3e13b765be5f4d1cba3cbbb79440c23d)

```jsx
// 논리합(||) 연산자
true || true; // -> true
true || false; // -> true
false || true; // -> true
false || false; // -> false

// 논리곱(&&) 연산자
true && true; // -> true
true && false; // -> false
false && true; // -> false
false && false; // -> false

// 논리 부정(!) 연산자
!true; // -> false
!false; // -> true
```

ㅍ

**참고!**

논리 **부정** **연산자**는 **항상 불리언 값**을 반환한다.

또한 **피연산자는** 반드시 **불리언이 아니여도** 된다.

→ 만약 불리언 값이 아니면 **암묵적**으로 **불리언 타입**으로 **변환**한다.

ex)

```jsx
// 암묵적 타입 변환
!0; // -> true
!'Hello'; // -> false
```

<br>

복잡한 논리연산자는 **드모르간 법칙**으로 활용하면 **가독성이 GOOD**!

```jsx
!(x || y) === (!x && !y);
!(x && y) === (!x || !y);
```

<br>

## 6. 쉼표 연산자

<br>

**쉼표 연산자( , )[용어]** 는 **왼쪽부터 차례대**로 피연산자를 **평가**하고

마지막 피연산자 평가가 끝나면

**마지막 피연산자** 평가 결과를 **반환**한다.

<br>

```jsx
var x, y, z;

(x = 1), (y = 2), (z = 3); // 3
```

<br>

## 7. 그룹 연산자

<br>

**그룹 연산자[용어]** 는 소괄호() 로 피연산자를 감싼다.

**그룹연산자**로 만들어서 가장 **먼저 평가**하는 **연산자 우선순위**를 조절한다.

<br>

```jsx
10 * 2 + 3; // -> 23

// 그룹 연산자를 사용하여 우선순위를 조절
10 * (2 + 3); // -> 50
```

<br>

## 8. typeof 연산자

<br>

**typeof 연산자[용어]** 는 피연산자 **데이터 타입을 문자열**로 반환한다.

<br>

**What 무슨 문자열?**

총 7가지로

1. string
2. number
3. boolean
4. undefined
5. symbol
6. object
7. function

중 하나를 반환한다.

→ 데이터 타입에 있는 **null은 반환하지 않는다.**

그래서 7개의 **데이터 타입과 일치하지 않는다.**

<br>

```jsx
typeof ''; // -> "string"
typeof 1; // -> "number"
typeof NaN; // -> "number"
typeof true; // -> "boolean"
typeof undefined; // -> "undefined"
typeof Symbol(); // -> "symbol"
typeof null; // -> "object"
typeof []; // -> "object"
typeof {}; // -> "object"
typeof new Date(); // -> "object"
typeof /test/gi; // -> "object"
typeof function () {}; // -> "function"
```

<br>

null 을 object으로 반환하는 첫번째 JS 버그가 있다.

<br>

**How? 그럼 어떻게 null 타입을 확인할까?**

일치 연산자 (===)를 사용하면된다.

<br>

```jsx
var foo = null;

typeof foo === null; // -> false
foo === null; // -> true
```

<br>

**주의2!**

**선언하지 않은 식별자**는 `undefined` 로 반환한다.

```jsx
// undeclared 식별자를 선언한 적이 없다.
typeof undeclared; // -> undefined
```

<br>

## 9. 지수 연산자

<br>

ES7에서 추가된 **지수연산자[용어]** 는

**좌항**의 피연산자를 **밑**으로

**우항**의 피연산자를 **지수로 거듭제곱** 하여

숫자값을 **반환**한다.

<br>

```jsx
2 ** 2; // -> 4
2 ** 2.5; // -> 5.65685424949238
2 ** 0; // -> 1
2 ** -2; // -> 0.25
```

<br>

**TIP!**

지수 연산자는 이항연산자 중 **우선순위가 가장 높다**

<br>

## 10. 그 외의 연산자

<br>

그외의 다른 연산자는 다음 챕터에서 정리

<br>

## 11. 연산자의 부수 효과

<br>

**부수효과(side effect)[용어]** 로 피연산자의 **값이 변하는** 연산자들이 있다.

<br>

**What? 무엇이 있을까?**

할당(=) 연산자, 증가/감소(++/–) 연산자, delete 연산자

ㅍ

```jsx
// 할당 연산자는 변수 값이 변하는 부수 효과가 있다.
// 이는 x 변수를 사용하는 다른 코드에 영향을 준다.
x = 1;
console.log(x); // 1

// 증가/감소 연산자(++/--)는 피연산자의 값을 변경하는 부수 효과가 있다.
// 피연산자 x의 값이 재할당되어 변경된다. 이는 x 변수를 사용하는 다른 코드에 영향을 준다.
x++;
console.log(x); // 2

var o = { a: 1 };

// delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.
// 이는 o 객체를 사용하는 다른 코드에 영향을 준다.
delete o.a;
console.log(o); // {}
```

<br>

## 12. 연산자 우선순위

<br>

<br>

연산자는 먼저 실행되는 **우선순위**가 있다.

<br>

**TIP!**

종류가 많아 기억하기 쉽지 않으므로

**우선순위가** **가장 높은 그룹연산자**로

명시적으로 **조절을 권장**한다!

<br>

## 13. 연산자 결합 순서

<br>

**연산자 결합 순서[용어] 연산자의 어느쪽 부터 평가 수행할지 나타내는 순서이다.**

[연산자 결합 순서](https://www.notion.so/e50759b41e654174ac16c859cf571749)
